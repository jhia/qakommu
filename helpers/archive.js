const fs = require('fs');
const path = require('path');
const { makeid } = require('./utilities');

const cloudinary = require('cloudinary').v2

/**
 * Type:File
 * @param {string} name file name
 * @param {Buffer} data file content in buffer
 * @param {integer} size total buffer size 29887
 * @param {string} encoding size of chunks
 * @param {string} tempFilePath temp file path
 * @param {boolean} truncated is a truncated request
 * @param {string} mimetype image encoding image/jpeg
 * @param {string} md5 signature in MD5
 * @param {Function} mv function to auto save file in path
 * @example
 * {
 *   name: 'IMG-20201114-WA0016.jpg',
 *   data: <Buffer ff d8 ff e0 00 10 4a 46 49 46 00 01 01 00 00 01 00 01 00 00 ff db 00 84 00 0a 0a 0a 0a 0a 0a 0b 0c 0c 0b 0f 10 0e 10 0f 16 14 13 13 14 16 22 18 1a 18 ... 29837 more bytes>,
 *   size: 29887,
 *   encoding: '7bit',
 *   tempFilePath: '',
 *   truncated: false,
 *   mimetype: 'image/jpeg',
 *   md5: 'f8e7842f53b73d6f9e71d30ff2051eb0',
 *   mv: [Function: mv]
 * }

 */

/**
 * Type for archives and images
 * @example
 * let image = new Archive('test', req.files.image)
 * await image.upload() // saved on the server
 * console.log(image.route) // /upload/test_123456.png
 */
class Archive {
  /**
   * @param {string} tag - image base name, before _ 
   * @param {File} file - image file, form-data image
   * @param {string} id - unique id, after _, is generated by default
   */
  constructor(tag, file, id = null) {
    this.suffix = file.name.split('.').slice(-1);
    this.base = tag;
    this.id = id;
    if(!id) {
      this.id = `${this.base}/${this.base}_${makeid(6)}`;
      console.log('ID', this.id)
    }
    this.file = file;
    this.route = file.path || file.tempFilePath;
  }

  /**
   * Create new archive from Archive file
   * @param {Archive} archive image file, form-data image 
   * @return {Archive}
   */
  static from(archive) {
    return new Archive(archive.base, archive.file, archive.id);
  }

  /**
   * Create new archive from image name
   * @param {string} id image name
   */
  static async fromString(id) {
    let [base, rest] = id.split('/');
    let url = await Archive.route(id)
    let [_, suffix] = url.slice(-5).split('.')
    return new Archive(base, { name: `${rest}.${suffix}`, path: url, tempFilePath: url }, id);
  }

  get fileRoute() {
    return path.join('./', 'upload', `${this.id.split('/')[1]}.${this.suffix}`);
  }

  static async route(id) {
    return await cloudinary.url(id, {
      secure: true
    })
  }
  /**
   * save into server
   */
  upload() {
    if(!this.file.mv) {
      throw new Error('Cannot update without save function mv');
    }
    return new Promise((resolve, reject) => {
      this.file.mv(this.fileRoute, (fileErr) => {
        if(fileErr) {
          return reject(fileErr)
        }
        console.log('ROUTE', this.fileRoute)

        cloudinary.uploader.upload(this.fileRoute, {
          public_id: this.id,
          tags: this.base,
          secure: true
        }, (imageErr, image) => {
          if(imageErr) {
            return reject(imageErr)
          }
          console.log('IMAGE', image);
          this.route = image.secure_url;
          this.id = image.public_id;
          fs.unlink(this.fileRoute, (unlinkErr) => {
            if(unlinkErr) {
              return reject(unlinkErr)
            }
            return resolve(image);
          });
        })
      });
    })
  }

  /**
   * delete from server
   */
  remove() {
    return cloudinary.uploader.destroy(this.id);
  }
}

module.exports = Archive;